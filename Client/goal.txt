/*
Haxe Live Editor Prototype
Single-file prototype containing multiple logical files separated by comments.
Adapt to your project layout (Client/src, Shared/src, Server/src) as needed.

Requirements: haxe, haxeui-core, haxeui-openfl/html5 or other backend, sys.db for SQLite
*/

// ---- SQL Schema (sqlite) ----
/*
CREATE TABLE Page (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  slug TEXT NOT NULL UNIQUE,
  title TEXT,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  published_version_id INTEGER,
  latest_version_id INTEGER
);

CREATE TABLE PageVersion (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  page_id INTEGER NOT NULL,
  version_num INTEGER NOT NULL,
  title TEXT,
  layout TEXT,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  created_by TEXT,
  UNIQUE(page_id, version_num)
);

CREATE TABLE PageComponent (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  page_version_id INTEGER NOT NULL,
  sort_order INTEGER NOT NULL,
  type TEXT NOT NULL,
  data_json TEXT,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP
);
*/

// -----------------------------------------------------------------------------
// File: Shared/DTOs.hx
// -----------------------------------------------------------------------------
package shared;

typedef PageComponentDTO = {
    id:Int,
    type:String,
    sort:Int,
    data:Dynamic
};

typedef PageVersionDTO = {
    id:Int,
    pageId:Int,
    title:String,
    layout:String,
    components:Array<PageComponentDTO>
};

typedef PageDTO = {
    pageId:Int,
    title:String,
    layout:String,
    components:Array<PageComponentDTO>
};

// -----------------------------------------------------------------------------
// File: Shared/ComponentInterfaces.hx
// -----------------------------------------------------------------------------
package shared;

import haxe.ui.core.Component;

interface IPageComponent {
    public var id(get, set):String;
    public var type(get, set):String;
    public var props(get, set):Dynamic;

    function render():Component;
}

// -----------------------------------------------------------------------------
// File: Client/ComponentImplementations.hx
// -----------------------------------------------------------------------------
package client.components;

import shared.IPageComponent;
import haxe.ui.core.Component;
import haxe.ui.containers.VBox;
import haxe.ui.components.Label;
import haxe.ui.components.Image;
import haxe.Json;

class TextComponent implements IPageComponent {
    public var id:String;
    public var type:String = "text";
    public var props:Dynamic;

    public function new(?id:String) {
        this.id = id == null ? StringTools.replace(Math.random().toString(), "0.", "id_") : id;
        this.props = { text: "" };
    }

    public function render():Component {
        var box = new VBox();
        var label = new Label();
        label.text = Std.string(props.text);
        label.percentWidth = 100;
        box.addComponent(label);
        return box;
    }
}

class ImageComponent implements IPageComponent {
    public var id:String;
    public var type:String = "image";
    public var props:Dynamic;

    public function new(?id:String) {
        this.id = id == null ? StringTools.replace(Math.random().toString(), "0.", "img_") : id;
        this.props = { url: "", alt: "" };
    }

    public function render():Component {
        var img = new Image();
        img.resource = Std.string(props.url);
        img.percentWidth = 100;
        return img;
    }
}

// -----------------------------------------------------------------------------
// File: Client/ComponentFactory.hx
// -----------------------------------------------------------------------------
package client;

import shared.IPageComponent;
import client.components.TextComponent;
import client.components.ImageComponent;

class ComponentFactory {
    public static function create(type:String, ?id:String):IPageComponent {
        return switch(type) {
            case "text": new TextComponent(id);
            case "image": new ImageComponent(id);
            case _:
                // default to text component for unknown types
                new TextComponent(id);
        }
    }
}

// -----------------------------------------------------------------------------
// File: Shared/Serialization.hx
// -----------------------------------------------------------------------------
package shared;

import sys.db.Connection;
import haxe.Json;

class PageSerializer {
    var conn:Connection;
    public function new(conn:Connection) {
        this.conn = conn;
    }

    public function savePageVersion(page:PageDTO):Int {
        // get next version number
        var rs = conn.request("SELECT COALESCE(MAX(version_num),0)+1 AS nextVer FROM PageVersion WHERE page_id = ?", [page.pageId]);
        var nextVer = 1;
        if (rs.hasNext()) nextVer = rs.next().getInt(0);

        conn.request("INSERT INTO PageVersion (page_id, version_num, title, layout) VALUES (?, ?, ?, ?)", [page.pageId, nextVer, page.title, page.layout]);
        var versionId = conn.lastInsertId();

        for (comp in page.components) {
            var jsonData = Json.stringify(comp.data);
            conn.request("INSERT INTO PageComponent (page_version_id, sort_order, type, data_json) VALUES (?, ?, ?, ?)", [versionId, comp.sort, comp.type, jsonData]);
        }

        conn.request("UPDATE Page SET latest_version_id = ? WHERE id = ?", [versionId, page.pageId]);
        return versionId;
    }
}

// -----------------------------------------------------------------------------
// File: Shared/Loader.hx
// -----------------------------------------------------------------------------
package shared;

import sys.db.Connection;
import haxe.Json;

class PageLoader {
    var conn:Connection;
    public function new(conn:Connection) { this.conn = conn; }

    public function loadLatest(pageId:Int):PageVersionDTO {
        var rs = conn.request("SELECT latest_version_id FROM Page WHERE id = ?", [pageId]);
        if (!rs.hasNext()) throw 'Page not found: ' + pageId;
        var versionId = rs.next().getInt(0);
        return loadVersion(versionId);
    }

    public function loadVersion(versionId:Int):PageVersionDTO {
        var rs = conn.request("SELECT id, page_id, title, layout FROM PageVersion WHERE id = ?", [versionId]);
        if (!rs.hasNext()) throw 'Version not found: ' + versionId;
        var v = rs.next();
        var dto:PageVersionDTO = {
            id: v.getInt(0),
            pageId: v.getInt(1),
            title: v.getString(2),
            layout: v.getString(3),
            components: []
        };

        var rs2 = conn.request("SELECT id, sort_order, type, data_json FROM PageComponent WHERE page_version_id = ? ORDER BY sort_order ASC", [versionId]);
        while (rs2.hasNext()) {
            var c = rs2.next();
            dto.components.push({
                id: c.getInt(0),
                sort: c.getInt(1),
                type: c.getString(2),
                data: Json.parse(c.getString(3))
            });
        }
        return dto;
    }
}

// -----------------------------------------------------------------------------
// File: Client/PageRenderer.hx
// -----------------------------------------------------------------------------
package client.ui;

import haxe.ui.core.Component;
import haxe.ui.containers.VBox;
import shared.PageVersionDTO;
import client.ComponentFactory;

class PageRenderer {
    public function new() {}

    public function render(page:PageVersionDTO):Component {
        var root = new VBox();
        root.percentWidth = 100;
        for (comp in page.components) {
            var inst = ComponentFactory.create(comp.type, Std.string(comp.id));
            inst.props = comp.data;
            var node = inst.render();
            root.addComponent(node);
        }
        return root;
    }
}

// -----------------------------------------------------------------------------
// File: Client/EditorApp.hx
// -----------------------------------------------------------------------------
package client.app;

import haxe.ui.backend.UIManager;
import haxe.ui.containers.HBox;
import haxe.ui.containers.VBox;
import haxe.ui.components.ListView;
import haxe.ui.components.Button;
import haxe.ui.components.Label;
import haxe.ui.components.TextInput;
import haxe.ui.core.Component;
import shared.PageVersionDTO;
import shared.PageComponentDTO;
import client.components.TextComponent;
import client.ComponentFactory;
import haxe.Json;
import sys.db.Connection;
import shared.PageLoader;
import shared.PageSerializer;
import client.ui.PageRenderer;

class EditorApp {
    var root:HBox;
    var componentList:ListView;
    var canvas:VBox;
    var inspector:VBox;
    var conn:Connection;
    var pageDto:PageVersionDTO;
    var editorComponents:Array<IMap<String, Dynamic>>; // lightweight in-memory model

    public function new(conn:Connection) {
        this.conn = conn;
        buildUi();
    }

    function buildUi():Void {
        root = new HBox();
        root.percentWidth = 100;
        root.percentHeight = 100;

        // Left: palette
        var left = new VBox();
        left.percentWidth = 20;
        componentList = new ListView();
        componentList.dataProvider = ["text", "image"];
        left.addComponent(new Label().set_text("Components"));
        left.addComponent(componentList);
        var addBtn = new Button();
        addBtn.text = "Add";
        addBtn.onClick = function(e) {
            var t = componentList.selectedItem;
            if (t == null) return;
            addComponent(Std.string(t));
        }
        left.addComponent(addBtn);

        // Center: canvas
        canvas = new VBox();
        canvas.percentWidth = 60;

        // Right: inspector
        inspector = new VBox();
        inspector.percentWidth = 20;

        root.addComponent(left);
        root.addComponent(canvas);
        root.addComponent(inspector);
    }

    public function loadPageById(pageId:Int):Void {
        var loader = new PageLoader(conn);
        pageDto = loader.loadLatest(pageId);
        hydrateToEditor(pageDto);
    }

    function hydrateToEditor(dto:PageVersionDTO):Void {
        editorComponents = [];
        canvas.removeAllComponents();
        for (c in dto.components) {
            var comp = {
                id: Std.string(c.id),
                type: c.type,
                props: c.data
            };
            editorComponents.push(comp);
            var node = renderEditorComponent(comp);
            canvas.addComponent(node);
        }
    }

    function renderEditorComponent(comp:Dynamic):Component {
        var inst = ComponentFactory.create(comp.type, comp.id);
        inst.props = comp.props;
        var node = inst.render();

        // make selectable (very simple)
        node.onClick = function(e) {
            showInspector(comp);
        }
        return node;
    }

    function showInspector(comp:Dynamic):Void {
        inspector.removeAllComponents();
        inspector.addComponent(new Label().set_text("Inspector"));
        inspector.addComponent(new Label().set_text("Type: " + comp.type));
        var ti = new TextInput();
        ti.text = Std.string(comp.props.text == null ? "" : comp.props.text);
        ti.onChange = function(e) {
            comp.props.text = ti.text;
            refreshCanvas();
        }
        inspector.addComponent(ti);

        var saveBtn = new Button();
        saveBtn.text = "Save Draft";
        saveBtn.onClick = function(e) { saveDraft(); }
        inspector.addComponent(saveBtn);
    }

    function refreshCanvas():Void {
        // re-render whole canvas (simple approach)
        canvas.removeAllComponents();
        for (comp in editorComponents) {
            canvas.addComponent(renderEditorComponent(comp));
        }
    }

    function addComponent(type:String):Void {
        var comp = { id: StringTools.replace(Math.random().toString(), "0.", "c_"), type: type, props: {} };
        switch(type) {
            case "text": comp.props = { text: "New text" };
            case "image": comp.props = { url: "/uploads/placeholder.png" };
            default: comp.props = {};
        }
        editorComponents.push(comp);
        canvas.addComponent(renderEditorComponent(comp));
    }

    function saveDraft():Void {
        // build PageDTO
        var p:shared.PageDTO = {
            pageId: pageDto.pageId,
            title: pageDto.title,
            layout: pageDto.layout,
            components: []
        };
        for (i in 0...editorComponents.length) {
            var ec = editorComponents[i];
            p.components.push({ id: 0, type: ec.type, sort: i, data: ec.props });
        }
        var serializer = new PageSerializer(conn);
        var vid = serializer.savePageVersion(p);
        trace('Saved version: ' + vid);
    }
}

// -----------------------------------------------------------------------------
// File: Client/Main.hx
// -----------------------------------------------------------------------------
package client;

import sys.db.Sqlite;
import sys.db.Connection;
import client.app.EditorApp;

class Main {
    static public function main() {
        // open or create sqlite db
        var dbPath = 'cms.db';
        var conn = Sqlite.open(dbPath);

        var app = new EditorApp(conn);
        // For demo: ensure a page exists with id=1
        // In real app, create page rows, etc.
        try {
            app.loadPageById(1);
        } catch(e:Dynamic) {
            trace('Error loading page: ' + e);
        }

        // Hook root to HaxeUI UI system
        // For different backends you need to attach `app.root` to the stage/window.
        // Example (OpenFL target) - pseudocode:
        // var uiRoot = app.root;
        // Lib.current.stage.addChild(uiRoot.displayObject);
    }
}

// -----------------------------------------------------------------------------
// File: Shared/RestoreVersion.hx (added)
// -----------------------------------------------------------------------------
package shared;

import sys.db.Connection;

class VersionRestorer {
    var conn:Connection;
    public function new(conn:Connection) {
        this.conn = conn;
    }

    /**
     * Restores a given version as the latest version of a page.
     * This does NOT overwrite the old version—Instead, it creates
     * a NEW version cloned from the previous one.
     */
    public function restoreVersion(versionId:Int):Int {
        // Load the old version
        var loader = new PageLoader(conn);
        var v = loader.loadVersion(versionId);

        // Build DTO for new version
        var p:PageDTO = {
            pageId: v.pageId,
            title: v.title,
            layout: v.layout,
            components: []
        };
        for (c in v.components) {
            p.components.push({
                id: 0,
                type: c.type,
                sort: c.sort,
                data: c.data
            });
        }

        // Save as new version
        var serializer = new PageSerializer(conn);
        var newVersionId = serializer.savePageVersion(p);
        return newVersionId;
    }
}

/*
Notes:
- This is a prototype skeleton. You will need to wire HaxeUI root components to your backend (OpenFL/HTML5).
- The prototype intentionally uses simple re-rendering for clarity. For production, optimize incremental updates.
- Add drag/drop, undo, component config panels, image upload handlers, and validations as needed.
- You can split each "File" section above into real files in your repository.
*/

## AI Generator Component

### Overview
A new component type that allows users to enter a natural language prompt and upload assets. The AI then generates structured page JSON which is injected into the current page. This component integrates directly with the live editor and versioning.

### Component Schema
```
{
  "type": "ai_generator",
  "id": "comp_ai_001",
  "props": {
    "prompt": "",
    "assets": [],
    "status": "idle",
    "lastOutput": null
  }
}
```

### Database Schema (SQLite)
```
CREATE TABLE page_assets (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    pageId INTEGER,
    filename TEXT NOT NULL,
    mime TEXT NOT NULL,
    data BLOB NOT NULL,
    createdAt TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY(pageId) REFERENCES pages(id)
);
```

### Haxe Component (Editor UI)
```
class AiGeneratorComponent extends BaseComponent {
    public var prompt:String = "";
    public var assets:Array<UploadedAsset> = [];
    public var status:String = "idle";
    public var lastOutput:Dynamic = null;

    override function render() {
        return VBox([
            TextArea({ value: prompt, onChange: v -> prompt = v }),
            FileUploadArea({ files: assets, onUpload: a -> assets.push(a) }),
            Button("Generate", () -> generatePage()).disabled(status == "loading"),
            if (lastOutput != null) JsonPreview(lastOutput)
        ]);
    }

    function generatePage() {
        status = "loading";
        Api.generatePageFromAi({ prompt: prompt, assets: assets })
            .then(output -> {
                lastOutput = output;
                injectGeneratedComponents(output.components);
                status = "done";
            });
    }
}
```

### Injecting AI-Generated Components
```
function injectGeneratedComponents(comps:Array<Dynamic>) {
    for (c in comps) {
        page.components.push(ComponentFactory.create(c.type, c));
    }
    editor.savePageVersion(page);
    editor.refresh();
}
```

### AI Response Structure Example
```
{
  "components": [
    { "id": "heroImage", "type": "image", "props": { "src": "asset:bg.jpg", "fit": "cover" } },
    { "id": "title1", "type": "text", "props": { "text": "Welcome", "style": "h1" } },
    { "id": "ctaRow", "type": "buttonRow", "props": { "buttons": [ {"label": "Start", "action": "/start"} ] } }
  ]
}
```

### Workflow Summary
1. User enters prompt.
2. User uploads assets.
3. AI produces component JSON.
4. Editor replaces or appends components.
5. A new page version is saved.


## Manual LLM Mode (Copy/Paste Prompt + Response)

### Overview
This mode allows the user to:
1. Generate a full AI prompt inside the editor.
2. Copy that prompt into any preferred LLM (ChatGPT, Claude, Gemini, local LLM, etc.).
3. Paste the JSON response back into the editor.
4. The editor validates and injects the components into the page.

This makes the system vendor‑agnostic and offline‑friendly.

### UI Additions to AiGeneratorComponent
```
override function render() {
    return VBox([
        Text("AI Prompt"),
        TextArea({ value: prompt, onChange: v -> prompt = v, height: 150 }),

        HBox([
            Button("Generate Prompt", () -> buildAiPrompt()),
            Button("Copy Prompt", () -> Clipboard.copy(prompt)).disabled(prompt == "")
        ]),

        if (generatedPrompt != null) TextArea({
            value: generatedPrompt,
            readOnly: true,
            height: 250
        }),

        Button("Paste AI Response", () -> pasteAiResponse()),

        if (manualResult != null) TextArea({
            value: manualResult,
            onChange: v -> manualResult = v,
            height: 250
        }),

        Button("Apply Result", () -> applyManualResult())
    ]);
}
```

### Building the AI Prompt
```
function buildAiPrompt() {
    generatedPrompt = 'You are a page builder AI. Generate JSON using this schema: ...';
    generatedPrompt += '
User request:' + prompt;
    generatedPrompt += '
Output ONLY valid JSON. No explanations.';
}
```

### Pasting AI Response
```
function pasteAiResponse() {
    manualResult = Clipboard.paste();
}
```

### Validating & Applying the AI Result
```
function applyManualResult() {
    try {
        var json = Json.parse(manualResult);
        injectGeneratedComponents(json.components);
        editor.savePageVersion(page);
    } catch (e) {
        Dialog.error("Invalid JSON", e.toString());
    }
}
```

### User Workflow
1. User enters a short natural-language prompt.
2. User clicks **Generate Prompt**.
3. System outputs a **LLM-ready system+user prompt**.
4. User clicks **Copy Prompt**.
5. User pastes it into any LLM.
6. LLM returns a JSON component list.
7. User clicks **Paste AI Response**.
8. User reviews or edits JSON.
9. User clicks **Apply Result**.
10. Components are inserted + new version saved.

### Benefits
- Works with **any** AI model.
- Works **offline** with local LLMs.
- Zero vendor lock-in.
- Allows power users to tweak the generated prompt.


## JSON Validator for Manual LLM Mode

### Overview
Adds a built-in JSON validator with:
- **Syntax checking** (parse errors)
- **Component schema validation** (missing fields, wrong types)
- **Inline error display**
- **Error highlighting** inside the editor textarea

### Validation Pipeline
```
function validateJson(input:String):ValidationResult {
    try {
        var parsed = Json.parse(input);
    } catch (e) {
        return { ok:false, errors:[{ message: 'Invalid JSON syntax', details:e.toString() }] };
    }

    var errors = [];

    if (!Reflect.hasField(parsed, 'components')) {
        errors.push({ message:'Missing "components" array' });
    } else if (!Std.isOfType(parsed.components, Array)) {
        errors.push({ message:'"components" must be an array' });
    } else {
        for (c in parsed.components) {
            if (!Reflect.hasField(c, 'type'))
                errors.push({ message:'Component missing type', component:c });

            if (!Reflect.hasField(c, 'id'))
                errors.push({ message:'Component missing id', component:c });

            if (!Reflect.hasField(c, 'props'))
                errors.push({ message:'Component missing props', component:c });
        }
    }

    if (errors.length > 0)
        return { ok:false, errors:errors };

    return { ok:true, errors:[] };
}
```

### UI Integration
```
Button("Validate JSON", () -> {
    var result = validateJson(manualResult);
    validationErrors = result.errors;
    validationOk = result.ok;
});

if (!validationOk) {
    VBox([
        for (e in validationErrors)
            Text('• ' + e.message).color(0xCC0000)
    ]);
}
```

### Error Highlighting (Simple Range Highlight)
```
function highlightErrorInTextArea(errorMessage:String) {
    // naive implementation: look for the component index mentioned in the error
    // editor passes highlight range to UI
}
```

### What Gets Validated
- JSON parsing
- Root structure must contain a `components` array
- Each component must include:
  - `id : String`
  - `type : String`
  - `props : Object`
- Optional: Validate props using a component registry

### ValidationResult Type
```
typedef ValidationResult = {
    ok: Bool,
    errors: Array<{ message:String, ?details:String, ?component:Dynamic }>
}
```

### Future Upgrades
- JSON path-based error locations
- Highlight exact line/column of parse error
- Schema definition per component type
- Suggest automatic fixes


## JSON Schema Definition

Below is a formal JSON‑Schema–style definition used to validate AI‑generated page JSON. This schema is designed to be easily extensible as new components are added.

### Root Schema
```
typedef PageSchema = {
    components: Array<ComponentSchema>
}
```

### Component Schema
```
typedef ComponentSchema = {
    id: String,
    type: String,
    props: Dynamic,
    ?children: Array<ComponentSchema>
}
```

### Component Registry Schema
A registry defines validation rules for each component type.
```
var ComponentDefinitions = [
    {
        type: "text",
        requiredProps: ["text"],
        propsSchema: {
            text: String,
            ?style: String
        }
    },
    {
        type: "image",
        requiredProps: ["src"],
        propsSchema: {
            src: String,
            ?fit: String,
            ?width: Int,
            ?height: Int
        }
    },
    {
        type: "buttonRow",
        requiredProps: ["buttons"],
        propsSchema: {
            buttons: Array<{ label:String, action:String }>
        }
    },
    {
        type: "ai_generator",
        requiredProps: [],
        propsSchema: {
            prompt: String,
            assets: Array<Dynamic>,
            status: String,
            lastOutput: Dynamic
        }
    }
];
```

### Validation Against Component Registry
```
function validateComponentAgainstSchema(c:Dynamic, def:Dynamic, errors:Array<String>) {
    // Check required props
    for (r in def.requiredProps) {
        if (!Reflect.hasField(c.props, r))
            errors.push('Component "' + c.id + '" missing required prop: ' + r);
    }

    // Check defined prop types (simple version)
    for (field in Reflect.fields(def.propsSchema)) {
        var expected = Reflect.field(def.propsSchema, field);
        if (Reflect.hasField(c.props, field)) {
            var actual = Reflect.field(c.props, field);

            switch Type.typeof(expected) {
                case TClass(String):
                    if (!Std.isOfType(actual, String))
                        errors.push('Prop "' + field + '" in component "' + c.id + '" must be String');
                case TClass(Int):
                    if (!Std.isOfType(actual, Int))
                        errors.push('Prop "' + field + '" in component "' + c.id + '" must be Int');
                case _:
                    // Complex types skipped for brevity
            }
        }
    }
}
```

### Full Validation Integration
```
function validatePageSchema(pageJson:Dynamic):ValidationResult {
    var errors = [];

    if (!Std.isOfType(pageJson.components, Array)) {
        errors.push('Root must contain a "components" array');
        return { ok:false, errors:errors };
    }

    for (c in pageJson.components) {
        var def = ComponentDefinitions.find(d -> d.type == c.type);
        if (def == null) {
            errors.push('Unknown component type: ' + c.type);
            continue;
        }

        validateComponentAgainstSchema(c, def, errors);
    }

    return { ok: errors.length == 0, errors: errors };
}
```

### Summary
This schema allows:
- strict validation of AI-generated components
- extension for new component types
- future support for nested structures via `children`
- integration with the live JSON validator


## Automatic Schema Generation from Haxe Typedefs

### Overview
This system automatically generates JSON Schema–style definitions from Haxe typedefs. This ensures your editor, validator, and AI generator always stay synchronized with the actual component models—no manual duplication.

This solution uses:
- **Compile-time macros** to read typedef structures
- **A registry** that collects all component typedefs
- **A generator** that produces JSON-schema–like objects
- **Optional runtime export** for LLM prompt generation

---

## 1. Component Typedefs (Example)
```
typedef TextProps = {
    text:String,
    ?style:String
}

typedef ImageProps = {
    src:String,
    ?fit:String,
    ?width:Int,
    ?height:Int
}

typedef ButtonRowProps = {
    buttons:Array<{ label:String, action:String }>
}
```

Each component is defined with a typedef for its props.

---

## 2. Component Registration Macro
```
@:autoBuild(shared.schema.SchemaBuilder.registerComponent())
class ComponentDefs {}
```

Any class annotated with `@:autoBuild` participates in schema registration.

---

## 3. Schema Builder Macro
```
class SchemaBuilder {
    macro public static function registerComponent():Array<Field> {
        var fields = Context.getBuildFields();
        var classType = Context.getLocalClass().get();

        var name = classType.name;
        var module = classType.module;

        var schema = SchemaTools.extractSchema(classType);
        SchemaRegistry.addSchema(name, schema);

        return fields;
    }
}
```

This runs at compile time and pulls in typedef metadata.

---

## 4. Extracting Schema From Typedef
```
class SchemaTools {
    public static function extractSchema(t:ClassType):Dynamic {
        var fields = t.fields.get();
        var props = {};
        var required = [];

        for (f in fields) {
            var name = f.name;
            var type = f.type;

            var isOptional = f.meta.has(':optional');
            if (!isOptional) required.push(name);

            Reflect.setField(props, name, typeToSchema(type));
        }

        return {
            requiredProps: required,
            propsSchema: props
        };
    }
}
```

---

## 5. Type → Schema Conversion
```
static function typeToSchema(t:Type):Dynamic {
    return switch (t) {
        case TInst(c, _):
            var name = c.toString();
            switch (name) {
                case "String": "string";
                case "Int": "int";
                case "Float": "float";
                default: "object";
            }
        case TAnonymous(a):
            var fields = a.get().fields;
            var obj = {};
            for (f in fields) Reflect.setField(obj, f.name, typeToSchema(f.type));
            obj;
        case TArray(t2):
            { type: "array", items: typeToSchema(t2) };
        case _:
            "any";
    }
}
```

---

## 6. Schema Registry
```
class SchemaRegistry {
    static var schemas:Map<String,Dynamic> = new Map();

    public static function addSchema(name:String, schema:Dynamic) {
        schemas.set(name, schema);
    }

    public static function getSchema(name:String):Dynamic {
        return schemas.get(name);
    }

    public static function exportAll():Dynamic {
        return schemas;
    }
}

